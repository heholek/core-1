
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/open-integration/core/pkg/modem/mock_dialer.go (82.4%)</option>
				
				<option value="file1">github.com/open-integration/core/pkg/modem/mock_file_creator.go (72.7%)</option>
				
				<option value="file2">github.com/open-integration/core/pkg/modem/mock_service_client_creator.go (85.7%)</option>
				
				<option value="file3">github.com/open-integration/core/pkg/modem/mock_service_starter.go (80.0%)</option>
				
				<option value="file4">github.com/open-integration/core/pkg/modem/modem.go (48.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by mockery v1.0.0. DO NOT EDIT.

package modem

import grpc "google.golang.org/grpc"
import mock "github.com/stretchr/testify/mock"

// mockDialer is an autogenerated mock type for the dialer type
type mockDialer struct {
        mock.Mock
}

// Dial provides a mock function with given fields: target, opts
func (_m *mockDialer) Dial(target string, opts ...grpc.DialOption) (*grpc.ClientConn, error) <span class="cov8" title="1">{
        _va := make([]interface{}, len(opts))
        for _i := range opts </span><span class="cov8" title="1">{
                _va[_i] = opts[_i]
        }</span>
        <span class="cov8" title="1">var _ca []interface{}
        _ca = append(_ca, target)
        _ca = append(_ca, _va...)
        ret := _m.Called(_ca...)

        var r0 *grpc.ClientConn
        if rf, ok := ret.Get(0).(func(string, ...grpc.DialOption) *grpc.ClientConn); ok </span><span class="cov0" title="0">{
                r0 = rf(target, opts...)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(*grpc.ClientConn)
                }</span>
        }

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(string, ...grpc.DialOption) error); ok </span><span class="cov0" title="0">{
                r1 = rf(target, opts...)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by mockery v1.0.0. DO NOT EDIT.

package modem

import io "io"
import mock "github.com/stretchr/testify/mock"

// mockFileCreator is an autogenerated mock type for the fileCreator type
type mockFileCreator struct {
        mock.Mock
}

// Create provides a mock function with given fields: dir, name
func (_m *mockFileCreator) Create(dir string, name string) (io.Writer, error) <span class="cov8" title="1">{
        ret := _m.Called(dir, name)

        var r0 io.Writer
        if rf, ok := ret.Get(0).(func(string, string) io.Writer); ok </span><span class="cov0" title="0">{
                r0 = rf(dir, name)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).(io.Writer)
                }</span>
        }

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(dir, name)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by mockery v1.0.0. DO NOT EDIT.

package modem

import grpc "google.golang.org/grpc"
import mock "github.com/stretchr/testify/mock"
import v1 "github.com/open-integration/core/pkg/api/v1"

// mockServiceClientCreator is an autogenerated mock type for the serviceClientCreator type
type mockServiceClientCreator struct {
        mock.Mock
}

// New provides a mock function with given fields: cc
func (_m *mockServiceClientCreator) New(cc *grpc.ClientConn) v1.ServiceClient <span class="cov8" title="1">{
        ret := _m.Called(cc)

        var r0 v1.ServiceClient
        if rf, ok := ret.Get(0).(func(*grpc.ClientConn) v1.ServiceClient); ok </span><span class="cov0" title="0">{
                r0 = rf(cc)
        }</span> else<span class="cov8" title="1"> {
                if ret.Get(0) != nil </span><span class="cov8" title="1">{
                        r0 = ret.Get(0).(v1.ServiceClient)
                }</span>
        }

        <span class="cov8" title="1">return r0</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Code generated by mockery v1.0.0. DO NOT EDIT.

package modem

import io "io"
import mock "github.com/stretchr/testify/mock"

// mockServiceStarter is an autogenerated mock type for the serviceStarter type
type mockServiceStarter struct {
        mock.Mock
}

// Exec provides a mock function with given fields: command, args, environ, detached, workingDir, binpath, logger
func (_m *mockServiceStarter) Exec(command string, args []string, environ []string, detached bool, workingDir string, binpath string, logger io.Writer) (int, error) <span class="cov8" title="1">{
        ret := _m.Called(command, args, environ, detached, workingDir, binpath, logger)

        var r0 int
        if rf, ok := ret.Get(0).(func(string, []string, []string, bool, string, string, io.Writer) int); ok </span><span class="cov0" title="0">{
                r0 = rf(command, args, environ, detached, workingDir, binpath, logger)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">var r1 error
        if rf, ok := ret.Get(1).(func(string, []string, []string, bool, string, string, io.Writer) error); ok </span><span class="cov0" title="0">{
                r1 = rf(command, args, environ, detached, workingDir, binpath, logger)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package modem

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "os"
        "strings"
        "sync"
        "time"

        v1 "github.com/open-integration/core/pkg/api/v1"
        "github.com/open-integration/core/pkg/logger"
        "github.com/xeipuuv/gojsonschema"
        "google.golang.org/grpc"
)

type (
        Modem interface {
                Init() error
                Call(service string, endpoint string, arguments map[string]interface{}, fd string) (string, error)
                Destory() error
                AddService(id string, name string, port string, path string) error
        }

        modem struct {
                services             map[string]*service
                logger               logger.Logger
                serviceLogDirectory  string
                wg                   *sync.WaitGroup
                logFileCreator       fileCreator
                dialer               dialer
                serviceStarter       serviceStarter
                serviceClientCreator serviceClientCreator
        }

        dialer interface {
                Dial(target string, opts ...grpc.DialOption) (*grpc.ClientConn, error)
        }

        serviceStarter interface {
                Exec(command string, args []string, environ []string, detached bool, workingDir string, binpath string, logger io.Writer) (int, error)
        }

        fileCreator interface {
                Create(dir string, name string) (io.Writer, error)
        }

        serviceClientCreator interface {
                New(cc *grpc.ClientConn) v1.ServiceClient
        }

        service struct {
                conn   *grpc.ClientConn
                client v1.ServiceClient
                ready  bool
                id     string
                server struct {
                        binPath string
                        port    string
                        pid     int
                }
                err          error
                tasksSchemas map[string]string
        }

        ModemOptions struct {
                Logger               logger.Logger
                ServiceLogDirectory  string
                FileCreator          fileCreator
                ServiceStarter       serviceStarter
                Dialer               dialer
                ServiceClientCreator serviceClientCreator
        }
)

func New(opt *ModemOptions) Modem <span class="cov0" title="0">{
        m := &amp;modem{
                logger:               opt.Logger,
                services:             make(map[string]*service),
                serviceLogDirectory:  opt.ServiceLogDirectory,
                serviceStarter:       opt.ServiceStarter,
                dialer:               opt.Dialer,
                serviceClientCreator: opt.ServiceClientCreator,
        }
        return m
}</span>

func (m *modem) Init() error <span class="cov8" title="1">{
        m.logger.Debug("Modem initializing started")
        for name, s := range m.services </span><span class="cov8" title="1">{
                m.wg.Add(1)
                go m.initService(name, s, m.logger.New("service", name))
        }</span>
        <span class="cov8" title="1">m.wg.Wait()

        err := strings.Builder{}
        for name, s := range m.services </span><span class="cov8" title="1">{
                if s.err != nil </span><span class="cov8" title="1">{
                        m.logger.Error("Service failed to start", "service", name, "err", s.err.Error())
                        err.WriteString(fmt.Sprintf("Serive: %s - Error: %s\n", name, s.err.Error()))
                }</span>
        }
        <span class="cov8" title="1">if err.Len() &gt; 0 </span><span class="cov8" title="1">{
                m.logger.Error("Modem initializing finished with error")
                return errors.New(err.String())
        }</span>
        <span class="cov8" title="1">m.logger.Debug("Modem initializing finished")
        return nil</span>
}

func (m *modem) Call(service string, endpoint string, arguments map[string]interface{}, fd string) (string, error) <span class="cov0" title="0">{
        log := m.logger.New("service", service, "endpoint", endpoint)
        log.Debug("Call service request")

        req := &amp;v1.CallRequest{
                Endpoint: endpoint,
                Fd:       fd,
        }
        argsJSON, err := json.Marshal(arguments)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">log.Debug("Validating arguments")
        err = m.isArgumentsValid(argsJSON, m.services[service].tasksSchemas[fmt.Sprintf("%s/%s", endpoint, "arguments.json")])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">log.Debug("Arguments are valid")
        req.Arguments = string(argsJSON)
        resp, err := m.services[service].client.Call(context.Background(), req)
        if err != nil </span><span class="cov0" title="0">{
                log.Debug("Call return with error", "err", err.Error())
                return "", err
        }</span>
        <span class="cov0" title="0">if resp.Status == v1.Status_Error </span><span class="cov0" title="0">{
                log.Debug("Call return with error", "err", resp.Error)
                return resp.Payload, fmt.Errorf(resp.Error)
        }</span>

        <span class="cov0" title="0">log.Debug("Call ended", "response", resp.Status)
        err = m.isResponsePayloadValid(resp.Payload, m.services[service].tasksSchemas[fmt.Sprintf("%s/%s", endpoint, "returns.json")])
        if err != nil </span><span class="cov0" title="0">{
                return resp.Payload, err
        }</span>

        <span class="cov0" title="0">return resp.Payload, nil</span>
}

func (m *modem) Destory() error <span class="cov0" title="0">{
        m.logger.Debug("Stopping all services")
        for name, service := range m.services </span><span class="cov0" title="0">{
                if err := service.conn.Close(); err != nil </span><span class="cov0" title="0">{
                        m.logger.Debug("Failed to close connection to service", "service", name)
                }</span>
                <span class="cov0" title="0">process, err := os.FindProcess(service.server.pid)
                if err != nil </span><span class="cov0" title="0">{
                        m.logger.Debug("Failed to find process of service", "service", name)
                }</span>
                <span class="cov0" title="0">if err := process.Signal(os.Interrupt); err != nil </span><span class="cov0" title="0">{
                        m.logger.Debug("Failed to send kill signal to service process", "service", name)
                }</span>
                <span class="cov0" title="0">m.logger.Debug("Service stopped", "service", name)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (m *modem) AddService(id string, name string, port string, path string) error <span class="cov0" title="0">{
        s := &amp;service{
                ready: false,
                id:    id,
        }
        s.server.binPath = path
        s.server.port = port
        m.services[name] = s
        return nil
}</span>

func (m *modem) initService(name string, svc *service, log logger.Logger) <span class="cov8" title="1">{
        log.Debug("Starting service", "port", svc.server.port)
        envs := []string{
                fmt.Sprintf("PORT=%s", svc.server.port),
        }
        logFile := fmt.Sprintf("%s-%s.log", name, svc.id)
        file, err := m.logFileCreator.Create(m.serviceLogDirectory, logFile)
        if err != nil </span><span class="cov8" title="1">{
                log.Error("Failed to create log file", "error", err.Error())
                svc.err = err
                m.wg.Done()
                return
        }</span>
        <span class="cov8" title="1">log.Debug("Logging file created", "file", name)
        logger := file
        detached := true
        pid, err := m.serviceStarter.Exec(svc.server.binPath, []string{""}, envs, detached, "", "", logger)
        if err != nil </span><span class="cov8" title="1">{
                log.Error("Serivce startup failed", "error", err.Error())
                svc.err = err
                m.wg.Done()
                return
        }</span>
        <span class="cov8" title="1">svc.server.pid = pid
        log.Debug("Server started")

        log.Debug("Dialing service")
        conn, err := m.dialer.Dial(fmt.Sprintf("localhost:%s", svc.server.port), grpc.WithInsecure())
        if err != nil </span><span class="cov8" title="1">{
                log.Error("Serivce dial failed", "error", err.Error())
                svc.err = err
                m.wg.Done()
                return
        }</span>
        <span class="cov8" title="1">log.Debug("Connection established")
        svc.conn = conn
        client := m.serviceClientCreator.New(conn)
        svc.client = client
        time.Sleep(2 * time.Second)
        log.Debug("Initializing service")
        resp, err := client.Init(context.Background(), &amp;v1.InitRequest{})
        if err != nil </span><span class="cov8" title="1">{
                log.Error("Serivce init call failed", "error", err.Error())
                svc.err = err
                m.wg.Done()
                return
        }</span>
        <span class="cov8" title="1">svc.tasksSchemas = resp.JsonSchemas
        m.wg.Done()
        return</span>
}

func (m *modem) isArgumentsValid(json []byte, schema string) error <span class="cov0" title="0">{
        if schema == "" </span><span class="cov0" title="0">{
                return nil // no schema given, no assertion required
        }</span>
        <span class="cov0" title="0">schemaLoader := gojsonschema.NewStringLoader(schema)
        jsonLoader := gojsonschema.NewBytesLoader(json)
        return m.isJSONValid(jsonLoader, schemaLoader)</span>
}

func (m *modem) isResponsePayloadValid(json string, schema string) error <span class="cov0" title="0">{
        if schema == "" </span><span class="cov0" title="0">{
                return nil // no schema given, no assertion required
        }</span>
        <span class="cov0" title="0">schemaLoader := gojsonschema.NewStringLoader(schema)
        jsonLoader := gojsonschema.NewStringLoader(json)
        return m.isJSONValid(jsonLoader, schemaLoader)</span>
}

func (m *modem) isJSONValid(json gojsonschema.JSONLoader, schema gojsonschema.JSONLoader) error <span class="cov0" title="0">{
        result, err := gojsonschema.Validate(schema, json)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !result.Valid() </span><span class="cov0" title="0">{
                message := strings.Builder{}
                for _, desc := range result.Errors() </span><span class="cov0" title="0">{
                        message.WriteString(desc.String())
                }</span>
                <span class="cov0" title="0">return fmt.Errorf(message.String())</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
